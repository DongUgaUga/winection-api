<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1:1 화상채팅 및 손 인식</title>

    <!-- MediaPipe 라이브러리 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
</head>
<body>
    <h1>1:1 화상채팅 및 손 인식</h1>

    <!-- 로컬 및 상대방의 영상 송출 영역 -->
    <video id="localVideo" autoplay playsinline style="border: 2px solid green; width: 640px; height: 480px; transform: scaleX(-1);"></video>
    <video id="remoteVideo" autoplay playsinline style="border: 2px solid red; width: 640px; height: 480px; transform: scaleX(-1);"></video>
    <!-- id="remoteVideo"에서 상대방 영상이 송출 되어야 함.(테스트 용도 구현x) -->

    <!-- 상태 및 손 정보 표시 -->
    <p id="peerStatus">클라이언트를 찾고 있습니다...</p>
    <p>내 손 정보: <span id="myHandInfo">[]</span></p>
    <p>상대방 손 정보: <span id="peerHandInfo"></span></p>

    <script>
        // 방 번호 입력 및 웹소켓 연결(테스트 용도)
        // 후에 해시 함수를 대입하여 임의의 방 번호 생성 예정
        let roomId = prompt("참여할 방 번호를 입력하세요 (예: room1)");

        // HTML 요소 선택
        const localVideo = document.getElementById("localVideo");
        const remoteVideo = document.getElementById("remoteVideo");
        const myHandInfo = document.getElementById("myHandInfo");
        const peerHandInfo = document.getElementById("peerHandInfo");
        const peerStatus = document.getElementById("peerStatus");

        // 웹소켓 서버와 연결 설정
        let serverIP = "192.168.1.8"; // API IP주소
        const ws = new WebSocket(`ws://${serverIP}:8000/ws/${roomId}`);

        let peerConnected = false; // 상대방 연결 여부 확인 변수
        let peerConnection = new RTCPeerConnection({
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" }  // Google STUN 서버 사용
            ]
        });

        // WebRTC 로직
        ws.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            console.log(data)
            
            // WebRTC 시그널 처리
            if (data.offer) {
                console.log("Received WebRTC offer");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                ws.send(JSON.stringify({ answer: answer }));
            }

            if (data.answer) {
                console.log("Received WebRTC answer");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
            }

            if (data.candidate) {
                console.log("Received ICE candidate:", data.candidate);
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }

            // 손 좌표 데이터 수신 처리
            if (data.hand_data) {
                console.log("수신된 손 좌표 데이터:", data.hand_data);
        
                // 내 손 정보 업데이트
                if (data.client_id === "self") {
                    console.log("내 손 좌표 업데이트");
                    myHandInfo.innerText = JSON.stringify(data.hand_data || "[]");
                }
        
                // 상대방 손 정보 업데이트
                if (data.client_id === "peer") {
                    console.log("상대방 손 좌표 업데이트");
                    peerHandInfo.innerText = JSON.stringify(data.hand_data || "[]");
                }
            }

            // 상대방 연결 상태 업데이트
            if (data.client_id === "peer") {
                peerConnected = true;
                peerStatus.innerText = "통신 중입니다.";
            }
            updatePeerStatus();
        };

        // ICE Candidate 송신
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log("Sending ICE candidate:", event.candidate);
                ws.send(JSON.stringify({ candidate: event.candidate }));
            }
        };

        // 상대방 스트림 수신
        peerConnection.ontrack = (event) => {
            console.log("Received remote stream");
            remoteVideo.srcObject = event.streams[0];
        };

        // 웹소켓 연결 성공
        ws.onopen = () => {
            console.log(`Connected to room ${roomId}`);
            startStreaming();
        };

        // 웹소켓 연결 종료
        ws.onclose = () => {
            console.log("서버와 연결이 종료되었습니다.");
            peerConnected = false;
            updatePeerStatus();
        };

        // 로컬 웹캠 스트리밍 시작 함수
        function startStreaming() {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then((stream) => {
                    localVideo.srcObject = stream;

                    // WebRTC: 로컬 트랙 추가
                    stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

                    // WebRTC: Offer 생성 및 송신
                    peerConnection.createOffer()
                        .then(offer => peerConnection.setLocalDescription(offer))
                        .then(() => ws.send(JSON.stringify({ offer: peerConnection.localDescription })));

                    // MediaPipe 초기화
                    const hands = new Hands({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` // MediaPipe API 호출
                    });

                    hands.setOptions({
                        maxNumHands: 2,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    const camera = new Camera(localVideo, {
                        onFrame: async () => {
                            await hands.send({ image: localVideo });
                        },
                        width: 640,
                        height: 480
                    });
                    camera.start();

                    // MediaPipe 손 좌표 추출 및 전송
                    hands.onResults((results) => {
                        if (results.multiHandLandmarks && results.multiHandedness) {
                            const handData = results.multiHandLandmarks.map((landmark, index) => ({
                                hand_type: results.multiHandedness[index].label === "Right" ? "왼손" : "오른손",
                                x: landmark[0].x.toFixed(2),
                                y: landmark[0].y.toFixed(2),
                                z: landmark[0].z.toFixed(2)
                            }));
                            ws.send(JSON.stringify({ hand_data: handData }));
                        }
                    });
                })
                .catch((err) => {
                    console.error("웹캠 접근 에러:", err);
                });
        }

        // 연결 상태 업데이트 함수
        function updatePeerStatus() {
            if (!peerConnected) {
                peerStatus.innerText = "클라이언트를 찾고 있습니다...";
                myHandInfo.innerText = "[]";
                peerHandInfo.innerText = "";
            }
        }
    </script>
</body>
</html>
